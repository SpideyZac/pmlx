<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>PMLX Updater</title>
        <script src="./lib/fflate.min.js"></script>

        <!-- Check for updates -->
        <script>
            const isDev = true; // Set to true for development, false for production

            /**
             * IndexedDB helper for simplified access to PMLX data.
             */
            class PMLXDB {
                constructor() {
                    this.dbName = "pmlx";
                    this.dbVersion = 2;
                    this.db = null;
                }

                /**
                 * Opens the IndexedDB connection, creating stores if needed.
                 * @returns {Promise<IDBDatabase>} The database instance.
                 */
                async open() {
                    if (this.db) return this.db;

                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(
                            this.dbName,
                            this.dbVersion
                        );

                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;

                            if (!db.objectStoreNames.contains("version")) {
                                db.createObjectStore("version");
                            }

                            if (!db.objectStoreNames.contains("files")) {
                                db.createObjectStore("files", {
                                    keyPath: "id",
                                });
                            }
                        };

                        request.onsuccess = (event) => {
                            this.db = event.target.result;
                            resolve(this.db);
                        };

                        request.onerror = () => reject(request.error);
                    });
                }

                /**
                 * Gets a value from the specified object store.
                 * @param {string} storeName - The object store name.
                 * @param {string} key - The key to fetch.
                 * @returns {Promise<any|null>} The value or null if not found.
                 */
                async get(storeName, key) {
                    const db = await this.open();
                    return new Promise((resolve) => {
                        const tx = db.transaction(storeName, "readonly");
                        const store = tx.objectStore(storeName);
                        const request = store.get(key);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => resolve(null);
                    });
                }

                /**
                 * Stores a value in the specified object store.
                 * @param {string} storeName - The object store name.
                 * @param {any} value - The value to store.
                 * @param {string} [key] - Optional key (if not using keyPath).
                 * @returns {Promise<boolean>} True if successful.
                 */
                async put(storeName, value, key) {
                    const db = await this.open();
                    return new Promise((resolve, reject) => {
                        const tx = db.transaction(storeName, "readwrite");
                        const store = tx.objectStore(storeName);
                        const request = key
                            ? store.put(value, key)
                            : store.put(value);
                        request.onsuccess = () => resolve(true);
                        request.onerror = () => reject(request.error);
                    });
                }

                /**
                 * Clears all entries in the specified object store.
                 * @param {string} storeName - The object store name.
                 * @returns {Promise<boolean>} True if successful.
                 */
                async clear(storeName) {
                    const db = await this.open();
                    return new Promise((resolve, reject) => {
                        const tx = db.transaction(storeName, "readwrite");
                        const store = tx.objectStore(storeName);
                        const request = store.clear();
                        request.onsuccess = () => resolve(true);
                        request.onerror = () => reject(request.error);
                    });
                }
            }

            const db = new PMLXDB();
            var isRelease = true; // For using the dev version of PMLX (has nothing to do with the urls to fetch from)
            let latestRelease;

            async function downloadAndExtractZip(url) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(
                            `Failed to fetch zip: ${response.statusText}`
                        );
                    }

                    const arrayBuffer = await response.arrayBuffer();
                    const zip = fflate.unzipSync(new Uint8Array(arrayBuffer));

                    for (const [filename, content] of Object.entries(zip)) {
                        const blob = new Blob([content]);
                        await db.put("files", { id: filename, blob });
                        console.log(`[PMLX Updater] Stored ${filename}`);
                    }
                } catch (error) {
                    console.error(
                        "[PMLX Updater] Error downloading or extracting zip:",
                        error
                    );
                }
            }

            /**
             * Gets the latest release version.
             * @returns {Promise<string|null>} The latest version or null on error.
             */
            async function getLatestRelease() {
                try {
                    if (isDev) return "dev-version1";
                    const response = await fetch(
                        "https://api.github.com/repos/SpideyZac/pmlx/releases/latest"
                    );
                    if (!response.ok) throw new Error("Network error");
                    const data = await response.json();
                    return data.tag_name;
                } catch (error) {
                    console.error(
                        "[PMLX Updater] Error fetching latest release:",
                        error
                    );
                    return null;
                }
            }

            /**
             * Gets the current installed version from IndexedDB.
             * @returns {Promise<string|null>} The current version or null if not found.
             */
            async function loadVersion() {
                const result = await db.get("version", "version");
                return result ?? null;
            }

            /**
             * Checks whether an update is needed by comparing current and latest versions.
             * Also updates the latestRelease variable.
             * @returns {Promise<boolean>} True if an update is required.
             */
            async function needsUpdate() {
                const latest = await getLatestRelease();
                const current = await loadVersion();
                if (!latest) {
                    latestRelease = current ?? "unknown";
                    return false;
                }

                latestRelease = latest;
                return !current || current !== latest;
            }

            /**
             * Downloads all required game files and updates the version.
             * Clears existing files before downloading.
             * @returns {Promise<boolean>} True if updated, false if already up to date.
             */
            async function downloadFiles() {
                if (!(await needsUpdate())) {
                    console.log("[PMLX Updater] PMLX is already up to date.");
                    return false;
                }

                await db.clear("files");

                console.log("[PMLX Updater] Downloading latest files...");
                let zipUrl;
                zipUrl =
                    "https://github.com/SpideyZac/pmlx/releases/latest/download/pmlx.zip";
                if (isDev) zipUrl = "./dist/pmlx.zip";
                await downloadAndExtractZip(zipUrl);

                // Store the new version
                await db.put("version", latestRelease, "version");
                return true;
            }

            /**
             * Main update logic: checks for updates, downloads files, and fetches patches.
             */
            (async () => {
                const updated = await downloadFiles();

                console.log(
                    "[PMLX Updater] Update complete, loading launcher..."
                );
                const launcherResponse = await db.get("files", "launcher.html");
                if (launcherResponse && launcherResponse.blob) {
                    const launcherText = await launcherResponse.blob.text();
                    document.documentElement.innerHTML = launcherText;

                    // Reinitialze scripts
                    const scripts = Array.from(
                        document.querySelectorAll("script")
                    );
                    for (const oldScript of scripts) {
                        const newScript = document.createElement("script");

                        for (const attr of oldScript.attributes) {
                            newScript.setAttribute(attr.name, attr.value);
                        }

                        newScript.textContent = oldScript.textContent;
                        document.head.appendChild(newScript);
                        oldScript.remove();
                    }
                } else {
                    console.error("[PMLX Updater] Missing launcher.html");
                }
            })();
        </script>
    </head>
</html>
